# Material

[Alle](https://www.iai.kit.edu/javavl/DhbwSlides.class)

[04_Primitive_Datentypen.pdf](https://www.iai.kit.edu/javavl/data/dhbw/2025-26/04_Primitive_Datentypen.pdf)

[05_Operatoren.pdf](https://www.iai.kit.edu/javavl/data/dhbw/2025-26/05_Operatoren.pdf)

## Primitive Datentypen

Für Variablen, Methodene, Klassen, Schnittstellen (und mehr), braucht man **Bezeichner** (Identifier).

Ein Bezeichner muss mit einem Buchstaben beginnen, Danach können Buchstaben und Zahlen folgen.

Gültig wäre theoretisch:

- `mami`
- `kulliReimtSichAufUlli`
- `IchMussWilliAnrufen`
- `RPHAEL_IST_LIEB`

Ungültig:

- `2undVier`
- `Meine Variable`
- `class` (Reserviertes Schlüsselwort)
- `hurtig!`

Es gibt einige Schlüsselwörter (reserved keywords), die nicht als Bezeichner verwendet werden können. Das sind für java: `abstract`,`assert`,`boolean`,`break`,`byte`,`case`,`catch`,`char`,`class`,`const`,`continue`,`default`,`do`,`double`,`else`,`enum`,`extends`,`final`,`finally`,`float`,`for`,`goto`,`if`,`implements`,`import`,`instanceof`,`int`,`interface`,`long`,`native`,`new`,`package`,`private`,`protected`,`public`,`return`,`short`,`static`,`strictfp`,`super`,`switch`,`synchronized`,`this`,`throw`,`throws`,`transient`,`try`,`void`,`volatile`,`while`.

Diese muss man allerdings nicht auswendig lernen. Die IDE warnt i.d.R., wenn man so ein keyword verwendet.

**Konventionen für Bezeichner:**

- Packages: Kleinschreibung. Trennung mit Punkt
- Klassen Interfaces: UpperCamelCase
- Methoden: lowerCamelCase
- Variablen: lowerCamelCase
- Konstanten: UPPER_SNAKE_CASE

**Dokumentation/Kommentare**

Man kann im Code Kommentare lassen, um zu einem späteren Zeitpunkt nachzuvollziehen, was einzelne Teile eines Codes machen.

Es gibt:

- Einzeillige Kommentare:

```java
// Dies ist ein Kommentar
public static void main(String[] args) { ... }
```

- Mehrzeillige Kommentare

```java
/*
lorem
ipsum
*/
public static void main(String[] args) { ... }
```

**Anweisungen**

Eine Anweisung (Statement) ist eine vom Programmierer erstellter Befehl zur Lösung einer Aufgabe. Ein Programm besteht aus einer Folge von Anweisungen.

- Es gibt einfache Anweisungen oder Anweisungsblöcke (oft scope genannt)
- Eine einfache Anweisung wird mit einem Semikolon abgeschlossen
- Ein Anweisungsblock beginnt mit `{` und endet mit `}`
- Anweisungsblöcke können geschachtelt werden
- Leere Anweisungen (nur Semikolon) sind auch erlaubt

```java
statement;

{
    statement1;
    statement2;
}
```

**Datentypen**

Eine Anweisung arbeitet mit Daten, die sich unterscheiden:

- Zahlen
- Zeichen
- Boolesche Daten

Java ist typensicher (typesafe).

Es gibt 2 Arten von Datentypen in Java:

- Primitive Datentypen (int, float ..)
- Referenzdatentypen (z.b. Klassen)

**Primitive Datentypen**

- Nummerische Datentypen: byte, schort, int, long, float, double
- Zeichen Datentyp(en): char
- Boolescher Datentyp: boolean

Alle Unicode zeichen werden in Java als `char` (16 bit) dargestellt. Der eigentlich gespeicherte Wert ist der Unicode Wert. `A` ist die Zahl 65, `a` die 97 und `1` die 49. Die ersten 127 Zeichen sind der ASCII Table.

**Literale für primitive Datentypen**

Im Quelltext verwendete Werte (z.B. Zahlen) werden als Literale bezeichnet.

Schreibweise:

- Integer: `-140`, `-1`. `0`, `124353`
- Gleitkommazahlen: `3.1415`, `4.56e3`, `4.56E3`, `-5.667e90`, `+6.777e-8`
- Long (Suffix `L` oder `l`): `126L`
- Float (Suffix `f` oder `F`): `100.0f`
- Boolean: `true` oder `false`

Alphanumerische Datentypen `char` und z.B. `String` werden zwischen Apostrophe gesetzt:

```java
char letter = 'X';
char letter2 = "ä";

String hello = "World"
String foo = "Bar \n Baz"
```

Stauerzeichen und reservierte Symbole könne mit `\` escaped werden: `\n`, `\t`, `\\`, `\"`. Unicodes mit `\u`, z.B. `\u0045`

Nochmal eine Übersicht über die primitiven Datentypen:

| Typ       | Größe  | Minimum     | Maximum                      | Defaultwert     | Beispiel   |
| --------- | ------ | ----------- | ---------------------------- | --------------- | ---------- |
| `boolean` | 8 bit  | –           | –                            | `false`         | `false`    |
| `char`    | 16 bit | Unicode $0$ | Unicode $2^{16}-1$           | `\u0000` (null) | `'a'`      |
| `byte`    | 8 bit  | $-128$      | $+127$                       | `(byte) 0`      | `34`       |
| `short`   | 16 bit | $-2^{15}$   | $+2^{15}-1$                  | `(short) 0`     | `21345`    |
| `int`     | 32 bit | $-2^{31}$   | $+2^{31}-1$                  | `0`             | `42322554` |
| `long`    | 64 bit | $-2^{63}$   | $+2^{63}-1$                  | `0L`            | `134567L`  |
| `float`   | 32 bit | $2^{-149}$  | $(2-2^{-32}) \cdot 2^{127}$  | `0.0f`          | `3.1415f`  |
| `double`  | 64 bit | $2^{-1074}$ | $(2-2^{-52}) \cdot 2^{1023}$ | `0.0d`          | `3.253245` |
| `void`    | –      | –           | –                            | –               | –          |


**Variablen**

Für Anweisungen werden Daten benötigt. Eine Variable ist ein Stück Speicherplatz im Arbeitsspeicher. Auf diesen Speicher wird über den Variablennamen zugegriffen.

Syntax:

`type identifier [= init_value] {, identifier [= init_value]};`

Werte kann man auch im nachhinein ändern:

`identifier = new_value;`

z.B.

```java
int a;

int b,c,d;

int e = 3;

int f = 3, g = 5;

e = 5;
```

Variablen sind immer nur innerhalb von ihrem Anweisungsblock (Scope gültig)

**Typkompatibilität und Typenkonversion**

Eine Variable kann nur einen Typen haben.

Wenn 2 Datentypen kompatibel sind, konvertiert Java sie automatisch. Mann kann auch explizit Typen konvertieren: 

`float number2 = (float) 123`

**Symbolische Konstanten**

Mit dem `final` Keyword kann man eine Variable unveränderlich machen; bzw. dafür sorgen, dass sie nur einmal zugewiesen werden kann:

```java
final double PI = 3.141592;
```

**Zeichenketten**

Für Strings gibt es keinen primitiven Datentyp, sondern die `String` Klasse. Java bringt aber semantische Sonderregeln mit, um mit dieser Klasse zu arbeiten.

Strings definiert man mit `String bezeichner = "Inhalt der Nachricht";`.

Zeichenketten kann mit verketten mit dem `+` Operator:

```java
String a = "Hallo";
String b = "Welt";

String c = a + " " + c; // Hallo Welt
```

**Syntax und Semantik**

**Syntax** legt fest, welche Ausdrücke erlaubt sind (sprachliche Form).

Deutsch: „Der Baum blüht.“ und „Der Baum spaziert.“ sind syntaktisch korrekte Sätze.

Beispiel aus Java: Nach dem Wort `class` folgt ein Wort und anschließend eine in geschweifte Klammern eingeschlossene Zeichenfolge.

**Semantik** legt die Bedeutung eines Ausdrucks der Sprache fest.

Beispiel aus Java: Das Schlüsselwort `class` leitet eine Klassendefinition ein. Das Wort direkt nach `class` ist der Name der Klasse.

## Operatioren und Ausdrücke

Ein Ausdruck ist eine Folge von Operatoren und Operanden, welche z.B. die Berechnung eines Wertes festlegt.

Es gibt verschiedene Arten von Operatoren:

- Unärer Operator: `i++`
- Binärer Operator: `a + b`
- Ternärer Operator: `a ? 1 : 2`

**Inkrement/Dekrement Operator**

```java
// i um 1 erhöhen
i++;
++i;
x = ++n; // x: 1, n: 1

// i um 1 verringern
i--;
--i;
x = n++; // x: 0, n: 1
```

**Typisierung von Operatoren**

| Typ              | Bezeichnung | Java-Datentypen                        |
| ---------------- | ----------- | -------------------------------------- |
| Integraler Typ   | `I`         | `byte`, `short`, `int`, `long`, `char` |
| Nummerischer Typ | `N`         | `I` und `float`, `double`              |
| Logischer Typ    | `L`         | `boolean`                              |
| Primitiver Typ   | `P`         | `N` und `L`                            |
| Referenz         | `R`         | Klassen und `Array`s (inkl. `String`)  |
| Alle Typen       | `A`         |                                        |

**Arithmetische Operatoren**

| Operator | Name                        | Priorität | Typisierung | Operanden | Assoziativität |
| -------: | --------------------------- | --------: | ----------- | --------: | -------------- |
|      `+` | Unäres Plus (Vorzeichen)    |         1 | `N`         |         1 | rechts         |
|      `-` | Unäres Minus (Vorz.-Umkehr) |         1 | `N`         |         1 | rechts         |
|      `+` | Addition                    |         3 | `N, N`      |         2 | links          |
|      `-` | Subtraktion                 |         3 | `N, N`      |         2 | links          |
|      `*` | Multiplikation              |         2 | `N, N`      |         2 | links          |
|      `/` | Division                    |         2 | `N, N`      |         2 | links          |
|      `%` | Rest (Modulo)               |         2 | `N, N`      |         2 | links          |

**Inkrement- und Dekrement-Operatoren**

| Operator | Name      | Priorität | Typisierung | Operanden | Assoziativität |
| -------: | --------- | --------: | ----------- | --------: | -------------- |
|     `++` | Inkrement |         1 | `N`         |         1 | rechts         |
|     `--` | Dekrement |         1 | `N`         |         1 | rechts         |

**Vergleichsoperatoren**

| Operator | Name          | Priorität | Typisierung | Operanden | Assoziativität |
| -------: | ------------- | --------: | ----------- | --------: | -------------- |
|     `==` | Gleichheit    |         6 | `A, A`      |         2 | links          |
|     `!=` | Ungleichheit  |         6 | `A, A`      |         2 | links          |
|      `<` | Kleiner       |         5 | `N, N`      |         2 | links          |
|     `<=` | Kleinergleich |         5 | `N, N`      |         2 | links          |
|      `>` | Größer        |         5 | `N, N`      |         2 | links          |
|     `>=` | Größergleich  |         5 | `N, N`      |         2 | links          |

**Logische Operatoren**

| Operator | Name             | Priorität | Typisierung | Operanden | Assoziativität |
| -------: | ---------------- | --------: | ----------- | --------: | -------------- |
|      `!` | Nicht (Negation) |         1 | `L`         |         1 | rechts         |
|      `&` | Und              |         7 | `L, L`      |         2 | links          |
|     `&&` | Und (verkürzt)   |        10 | `L, L`      |         2 | links          |
|   ` \| ` | Oder             |         9 | `L, L`      |         2 | links          |
|   `\|\|` | Oder (verkürzt)  |        11 | `L, L`      |         2 | links          |
|      `^` | Exklusives Oder  |         8 | `L, L`      |         2 | links          |

**Bitlogische Operatoren**

| Operator | Name             | Priorität | Typisierung | Operanden | Assoziativität |
| -------: | ---------------- | --------: | ----------- | --------: | -------------- |
|      `~` | Komplement       |         1 | `I`         |         1 | rechts         |
|      `&` | Bitw. Und        |         7 | `I, I`      |         2 | links          |
|     `\|` | Bitw. Oder       |         9 | `I, I`      |         2 | links          |
|      `^` | Bitw. Exkl. Oder |         8 | `I, I`      |         2 | links          |

**Bedingungsoperator**

| Operator | Name               | Priorität | Typisierung   | Operanden | Assoziativität |
| -------: | ------------------ | --------: | ------------- | --------: | -------------- |
|   `?  :` | Bedingungsoperator |        12 | `L`, `A`, `A` |         3 | rechts         |

**Zuweisungsoperatoren**

| Operator | Funktion                                           |
| -------- | -------------------------------------------------- |
| =        | Zuweisung                                          |
| +=       | Zuweisung mit Addition                             |
| -=       | Zuweisung mit Subtraktion                          |
| *=       | Zuweisung mit Multiplikation                       |
| /*       | Zuweisung mit Division                             |
| %=       | Zuweisung mit Modulo                               |
| &=       | Zuweisung mit UND (bitlogisch / logisch)           |
| \| =     | Zuweisung mit ODER (bitlogisch / logisch)          |
| ^=       | Zuweisung mit EXKLUSIV-ODER (bitlogisch / logisch) |

**Bedingungsoperator**

Abhängig von einer Bedingung, wird entweder ein Ausdruck oder ein anderer gewählt.

`condition ? expression1 : expression2`

**Ausgabe**

`System.out.println("Ich bin eine Zeile")`

Mit `System.out.printf()` kann man die bewährte `printf` Funktion verwenden, die man aus unix oder C kennt. [printf man](https://www.man7.org/linux/man-pages/man3/printf.3.html)

**Eingabe**

Wie so manch anderes auch, kann man Eingaben über verschiedene Wege machen. Eine Möglichkeit ist es, Javas `java.util.Scanner` Helper zu verwenden.

Diesen instanziiert man und hat dann mehrere Methoden zur Verfügung:

```java
java.util.Scanner scan = new java.util.Scanner(System.in);

int i = scan.nextInt(); // Eingabe für einen int fordern

double d = scan.nextDouble(); // Eingabe für double

String word = scan.next(); // Irgendein Input, ausgegeben als String
```

# Übungsaufgaben

[04_Primitive_Datentypen_Aufgaben.pdf](https://www.iai.kit.edu/javavl/data/dhbw/2025-26/04_Primitive_Datentypen_Aufgaben.pdf): [ShortValue.java](./ShortValue.java) [Round.java](./Round.java)

[05_Operatoren_Aufgaben.pdf](https://www.iai.kit.edu/javavl/data/dhbw/2025-26/05_Operatoren_Aufgaben.pdf): [IncrementDecrement.java](./IncrementDecrement.java) [Round.java](./Round.java) [Easter.java](./Easter.java) [Priority.java](./Priority.java)