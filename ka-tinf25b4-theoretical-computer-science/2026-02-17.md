# Material

TODO

## Formale Sprachen

z.B

- Nutzungsinterface zwischen Computer und Mensch
- Programmiersprachen

**Alphabet**

Ein Alphabet ist eine Menge von Zeichen / Symbolen:

Beispiel:

$\Sigma_{lat} = \{a,b,c,...,z\}$
$\Sigma_{2} = \{0,1\}$
$\Sigma_{\text{Unicode}} = \{x|x \text{ ist ein Zeichen im Unicode} \}$
$\Sigma_{\text{Logik}} = \{(,), \land, \lor, \neg \} \cup \Sigma_{lat}$ 


**Wort**

Ein Wort $w$ ist ein endliches oder leres Tupel von Zeichen $w_k \in \Sigma$ eines Alphabets mit Länge $|w|=n$ der Anzahl der Zeichen.

- Wörter werden meist ohne Klammern, also als $w_1w_2...$ geschrieben
- Das Epsilon $\epsilon$ nezeichnet ein leeres Wort (ohne Zeichen)

Es gibt besondere Mengen:

$$
\begin{align*}
\Sigma^0 := \{\epsilon\} \\
\Sigma^* := \bigcup_{n \ge 0}\Sigma^n \\
\Sigma^+ := \bigcup_{m \gt 0}\Sigma^n
\end{align*}
$$

m+ und m* sind irgendwas mit kleene ab schluss

TODO ^

**Kleene Abschluss**

$M = \{01, 2\}$, so ergeben sich u.a. diese Wortmengen:

$M^0 = \{\epsilon\}$
$M^1 = \{01, 2\}$
$M^2 = \{0101, 012, 201, 22\}$
$M^3 = \{010101, 01012, 01201, 0122, 20101, 2012, 2201, 222\}$

$M^+ = M^1 \cup M^2 \cup ... = \{02, 2, 0101, 012, 201, 22, 010101, 01012, ...\}$
$M^* = M^0 \cup M^+ = \{\epsilon, 02, 2, 0101, 012, 201, 22, 010101, 01012, ...\}$

Insbesondere hängt die Wortlänge $|w|$ für ein $w \in L*$ von der Definition des Alphabets L ab. So ist in diesem Beispiel $|222| = 3$ während $|0101| = 2$ ist.

TODO konkatination

**Abschluss**

Auf einer Menge mit einer Verknüpfung liefert jede Anwendung der Operation mti Elementen wieder ein Element aus der Menge.

Die Kleene-Abschlüsse und Multiplikationen werden später in regulären Ausdrücken auf Wördern verwendet, damit ist dann der Abschluss oder das kartesisiche Produkt der Menge mit genau diesem Wort gemeint:

$(ab)^+ = \{ab, abab, ababab, ...\}$

$cd*e = \{c\} \times \{d\}^* \times \{e\} = \{ce,, cde, cdde, cddde, ...\}$

**Formale Sprache**

Jede Teilnebge $L \subseteq \Sigma^*$ ist eine Formale Sprache über dem Alphabet $\Sigma$

Beispiel:

$L_\text{Java} = \{p \in \Sigma_\text{Unicode}^* | p \text{ ist ein syntaktisch korrektes Java Programm}\}$

**Collatz Problem**

TODO

## Komplexitätsklassen

Die **Berechenbarkeit** fragt, ob etwas berechnet werden kann.

Die **Komplexität** fragt, ob und wie die Berechnungsdauer von der Wortlänge abgeschätzt werden kann.

**Deterministische und Nicht-Deterministische Rechnenmodelle**

Deterministisches Rechenmodell (Turingmaschine): Klassischer Rechner mit einem Rechenkern in Von-Neumann-Architektur. Brute-Force möglich

Nichtdeterministisches Rechnenmodell: theoreitscher Rechner mit unendlich vielen Rechenkernen.

TODO: screenshot

Klassen:

- $L \in time(f)$, wenn es ein M gibt, die für $w \in L$ nach maximal $f(|w|)$ Schritten terminieren
- $L \in ntime(f)$, wenn es N gibt, die für $w \in L$ nach maximal $f(|w|)$ Schritten terminieren kann
- $L \in space(f)$, wenn es M gibt,für die $w \in L$ maximal $f(|w|)$ Speicher nutzt
- $L \in nspace(f)$, wenn es N gibt, die für $w \in L$ opt. maximal $f(|w|)$ Speicher nutzt

Komplexitätsklassen ... sind definiert durch:

$$
P := \bigcup_{k \in \mathbb{N}} time(n^k) \\
NP := \bigcup_{k \in \mathbb{N}} ntime(n^k) \\
PSPACE := \bigcup_{k \in \mathbb{N}} space(n^k) \\
NPSPACE := \bigcup_{k \in \mathbb{N}} nspace(n^k) \\
$$

$P \subseteq NP \subseteq PSPACE = NPSPACE$

Zwei Sprachen $L \subseteq \Sigma^*$ und $N \subseteq \Gamma^*$ sind polynomiell reduzierbar. wenn es eine in polynomiell beschränken Aufwand berechenbare Funktion gibt:

$$
\forall w \in \Gamma^* : w \in N \Leftrightarrow f(w) \in L
$$

Da jedes Problem auf L i ein Problem in N äquivalent umgeformt werden kann, so muss N mindestens so schwer sein wie L.

Eine Sprache L ist

- NP Schwer, wenn für alle $N \in NP$ gilt, dass $N \ge^{poly} L$
- NP vollständig, oder $L \in NPC$ (NP-complete), wenn $L$ NP-schwer und $L \in NP$ ist

Diese Definition stellt einerseits klar, dass entsprechende NP-Probleme tatsächlich schwierig sind, da sie auf alle anderen entsprechenden Probleme abildet werden. Doch sit die Eigenschaft NP-Schwer wirklich schwer nachzuweisen, wenn überhaupt nicht alle NP-Probleme bekannt sind.

**SAT-Problem**

Das **Erfüllbarkeitsproblem der Aussagenlogik** bezeichnet die Frage, ob es für einen gegebenen geklammerten logischen Ausdruck azs booleschen Variablen mit der logischen Operation vn Konjuktion, Disjunktion und Negation in konjunktiver Normalform eine Belegung der Variabeln gibt, so dass der Termin wahr wird.

$$
SAT = \{F |F \text{ ist boolescher Ausdruck und erfüllbar}\}
$$

- Alle NP-Probleme sind auf das SAT-Problem rückführbar durch die Definition der nichtdeterministischen Turingmaschinen.

Damit ist jedes Problem, das als SAT dargestellt werden kann NP-schwer.

**3SAT-Problem**

Das 3SAT-Problem bezeichnet die Frage, ob logische 

TODO

Jedes SAT-Problem kann in ein 3SAT-Problem umgeformt werden.

TODO: früheres sat problem zu 3sat (screenshot)

## Übungsaufgaben

49.

$\Sigma = \{a, el, en, g, l, ste\}$

> Welche Wörter kann ich aus der Kombination von 4 Elementen aus dem Alphabet bilden ($\Sigma^4$) ?

w1: g + a + l + g + ... (Nicht in 4 machbar)

w2: ste + l + l (e ist nicht abbildbar)

w3: (s nicht enthalten)

w4: l + a + g + en

TODO

---

50.

$\Sigma = \{be,che,ei,ler,ne,r\}$

> Welche Worte liegen in $\Sigma^4$

w1: r + ei + che + r

w2: r + ei + be ... (n nicht enthalten)

w3: (l nicht enthalten)

w4: r + ei + be + R

w5: r + ei .. (h nicht enthalten)

w6: r + ei + ne + r

---

51.

$\Sigma = \{e, en, in, r, t ,u\}$

> Welche Wörter liegen in $\Sigma^5$?

w1: r + e + in + e + r

w2: t + e + u + r + e ... (nicht in 5)

TODO

---

52.

$\Sigma = \{e, el, g, i, ne, st\}$

> $\sigma^5$

w1: ja

w2: ja

w3: nein

w4: nein

w5: nein

w6: nein

---

53.

$\Sigma = \{e,g,in,l,s,ter\}$

> Welche Wörter liegen in $\Sigma^*$?

w1: (t ist nicht enthalten)

w2: s + e + ... (i ist nicht enthalten)

TODO

---

54.

$\Sigma = \{ber, e, he, in, sch, u\}$

> $\Sigma^*$

54.

w1 : nein

w2: ja

w3: nein

w4: ja

w5: ja

w5: ja