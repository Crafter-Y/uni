# Material

Folien stehen nicht zur Verfügung.

[Theoretische-Informatik-I.pdf](https://moodle.dhbw.de/mod/resource/view.php?id=363680)

## Formale Sprachen

z.B

- Nutzungsinterface zwischen Computer und Mensch
- Programmiersprachen

**Alphabet**

Ein Alphabet ist eine Menge von Zeichen / Symbolen:

Beispiel:

$\Sigma_{lat} = \{a,b,c,...,z\}$
$\Sigma_{2} = \{0,1\}$
$\Sigma_{\text{Unicode}} = \{x|x \text{ ist ein Zeichen im Unicode} \}$
$\Sigma_{\text{Logik}} = \{(,), \land, \lor, \neg \} \cup \Sigma_{lat}$ 

**Wort**

Ein Wort $w$ ist ein endliches oder leres Tupel von Zeichen $w_k \in \Sigma$ eines Alphabets mit Länge $|w|=n$ der Anzahl der Zeichen.

- Wörter werden meist ohne Klammern, also als $w_1w_2...$ geschrieben
- Das Epsilon $\epsilon$ nezeichnet ein leeres Wort (ohne Zeichen)

Es gibt besondere Mengen:

$$
\begin{align*}
\Sigma^0 &:= \{\epsilon\} \\
\Sigma^* &:= \bigcup_{n \ge 0}\Sigma^n \\
\Sigma^+ &:= \bigcup_{m \gt 0}\Sigma^n
\end{align*}
$$

Die Operationen $M^*$ und $M^+$ auf einer Menge M wird auch Kleene-*-Abschluss oder Kleene-+-Abschluss genannt.

**Kleene Abschluss**

$M = \{01, 2\}$, so ergeben sich u.a. diese Wortmengen:

$M^0 = \{\epsilon\}$
$M^1 = \{01, 2\}$
$M^2 = \{0101, 012, 201, 22\}$
$M^3 = \{010101, 01012, 01201, 0122, 20101, 2012, 2201, 222\}$

$M^+ = M^1 \cup M^2 \cup ... = \{02, 2, 0101, 012, 201, 22, 010101, 01012, ...\}$
$M^* = M^0 \cup M^+ = \{\epsilon, 02, 2, 0101, 012, 201, 22, 010101, 01012, ...\}$

Insbesondere hängt die Wortlänge $|w|$ für ein $w \in L*$ von der Definition des Alphabets L ab. So ist in diesem Beispiel $|222| = 3$ während $|0101| = 2$ ist.

Für zwei Wörter $u = (u_1, ..., u_n)$ und $w = (w_1, ..., w_m)$ ist das Produkt oder Konkatenation:

$$
u \cdot w = uw = (u_1, ..., u_n,w_1, ..., w_m) = u_1, ..., u_n,w_1, ..., w_m
$$

Die n-te Potent eines Wortes $w$ ist:

$$
w^n = w \cdot ... \cdot w \text{ für }n\gt 0
$$

oder das leere Wort $w^0 = \epsilon$ für $n = 0$

**Abschluss**

Auf einer Menge mit einer Verknüpfung liefert jede Anwendung der Operation mti Elementen wieder ein Element aus der Menge.

Die Kleene-Abschlüsse und Multiplikationen werden später in regulären Ausdrücken auf Wördern verwendet, damit ist dann der Abschluss oder das kartesisiche Produkt der Menge mit genau diesem Wort gemeint:

$(ab)^+ = \{ab, abab, ababab, ...\}$

$cd*e = \{c\} \times \{d\}^* \times \{e\} = \{ce,, cde, cdde, cddde, ...\}$

**Formale Sprache**

Jede Teilnebge $L \subseteq \Sigma^*$ ist eine Formale Sprache über dem Alphabet $\Sigma$

Beispiel:

$L_\text{Java} = \{p \in \Sigma_\text{Unicode}^* | p \text{ ist ein syntaktisch korrektes Java Programm}\}$

**Collatz Problem**

Die Collatz-Funktion lautet:

$$
f(n) = \Bigg\{
\begin{matrix}
\frac{n}{2}, &\text{wenn }n\text{ gerade}\\
3n + 1, &\text{sonst}
\end{matrix}
$$

Das Collatz-Problem ist dann die Frage, ob es für ein gegebenes $n \in \mathbb{N}$ eine Konstante $k \in \mathbb{N}_0$ gibt, so dass die k-malig wiederholte Ausführung der Collatzfunktion f

$$
f^k(n) = \underbrace{f(f(...f(n)...))}_\text{k Ausführungen} = 1
$$

erstmals die Zahl 1 ergibt.

> Also ob es eine Zahl gibt, wenn man sie in diese Funktion rekursiv einsetzt irgendwann nicht 1 ergibt.

## Komplexitätsklassen

Die **Berechenbarkeit** fragt, ob etwas berechnet werden kann.

Die **Komplexität** fragt, ob und wie die Berechnungsdauer von der Wortlänge abgeschätzt werden kann.

**Deterministische und Nicht-Deterministische Rechnenmodelle**

Deterministisches Rechenmodell (Turingmaschine): Klassischer Rechner mit einem Rechenkern in Von-Neumann-Architektur. Brute-Force möglich

Nichtdeterministisches Rechnenmodell: 

- Theoreitscher Rechner mit unendlich vielen Rechenkernen. Algorithmen können für jeden Rechenschritt einen Thread starten.
- Ein theoretischer Rechner mit "Orakel", der jederzeit die beste Entscheidung wählt, die frühstmöglich zum Ergebnis führt.


Klassen:

- $L \in time(f)$, wenn es ein M gibt, die für $w \in L$ nach maximal $f(|w|)$ Schritten terminieren
- $L \in ntime(f)$, wenn es N gibt, die für $w \in L$ nach maximal $f(|w|)$ Schritten terminieren kann
- $L \in space(f)$, wenn es M gibt,für die $w \in L$ maximal $f(|w|)$ Speicher nutzt
- $L \in nspace(f)$, wenn es N gibt, die für $w \in L$ opt. maximal $f(|w|)$ Speicher nutzt

Komplexitätsklassen ... sind definiert durch:

$$
\begin{align*}
P &:= \bigcup_{k \in \mathbb{N}} time(n^k) \\
NP &:= \bigcup_{k \in \mathbb{N}} ntime(n^k) \\
PSPACE &:= \bigcup_{k \in \mathbb{N}} space(n^k) \\
NPSPACE &:= \bigcup_{k \in \mathbb{N}} nspace(n^k) \\
\end{align*}
$$

$P \subseteq NP \subseteq PSPACE = NPSPACE$

Zwei Sprachen $L \subseteq \Sigma^*$ und $N \subseteq \Gamma^*$ sind polynomiell reduzierbar. wenn es eine in polynomiell beschränken Aufwand berechenbare Funktion gibt:

$$
\forall w \in \Gamma^* : w \in N \Leftrightarrow f(w) \in L
$$

Da jedes Problem auf L i ein Problem in N äquivalent umgeformt werden kann, so muss N mindestens so schwer sein wie L.

Eine Sprache L ist

- NP Schwer, wenn für alle $N \in NP$ gilt, dass $N \ge^{poly} L$
- NP vollständig, oder $L \in NPC$ (NP-complete), wenn $L$ NP-schwer und $L \in NP$ ist

Diese Definition stellt einerseits klar, dass entsprechende NP-Probleme tatsächlich schwierig sind, da sie auf alle anderen entsprechenden Probleme abildet werden. Doch sit die Eigenschaft NP-Schwer wirklich schwer nachzuweisen, wenn überhaupt nicht alle NP-Probleme bekannt sind.

**SAT-Problem**

Das **Erfüllbarkeitsproblem der Aussagenlogik** bezeichnet die Frage, ob es für einen gegebenen geklammerten logischen Ausdruck azs booleschen Variablen mit der logischen Operation vn Konjuktion, Disjunktion und Negation in konjunktiver Normalform eine Belegung der Variabeln gibt, so dass der Termin wahr wird.

$$
SAT = \{F |F \text{ ist boolescher Ausdruck und erfüllbar}\}
$$

- Alle NP-Probleme sind auf das SAT-Problem rückführbar durch die Definition der nichtdeterministischen Turingmaschinen.

Damit ist jedes Problem, das als SAT dargestellt werden kann NP-schwer.

**3SAT-Problem**

Das 3SAT-Problem bezeichnet die Frage, ob logische Terme in konjunktiver Normalform mit maximal (oder genau) drei Literalen erfüllbar sind.

Jedes SAT-Problem kann in ein 3SAT-Problem umgeformt werden mit Hilfsvariablen.

Beispiel:

Das frühere Sat-Problem:

$$
f(x_1,x_2,x_3,x_4) = \overline{x_3} \land (x_1 \lor x_2) \land (\overline{x_2} \lor x_3 \lor \overline{x_2} \lor x_3) \land (x_4 \lor \overline{x_1})
$$

ist in dieses 3SAT-Problem überführbar:

$$
\begin{align*}
g(x,y) =&\quad (\overline{x_3} \lor \overline{x_3} \lor \overline{x_3}) \land (x_1 \lor x_2 \lor x_2) \\
&\land (\overline{x_2} \lor x_3 \lor y_1) \land (\overline{y_1}\lor\overline{x_2} \lor x_3) \\
&\land (x_4 \lor \overline{x_1} \lor \overline{x_1})
\end{align*}
$$

## Übungsaufgaben

49.

$\Sigma = \{a, el, en, g, l, ste\}$

> Welche Wörter kann ich aus der Kombination von 4 Elementen aus dem Alphabet bilden ($\Sigma^4$) ?

w1: g + a + l + g + ... (Nicht in 4 machbar)

w2: ste + l + l (e ist nicht abbildbar)

w3: (s nicht enthalten)

w4: l + a + g + en

w5: a + l + l + en

w6: a + a + l + en

---

50.

$\Sigma = \{be,che,ei,ler,ne,r\}$

> Welche Worte liegen in $\Sigma^4$

w1: r + ei + che + r

w2: r + ei + be ... (n nicht enthalten)

w3: (l nicht enthalten)

w4: r + ei + be + R

w5: r + ei .. (h nicht enthalten)

w6: r + ei + ne + r

---

51.

$\Sigma = \{e, en, in, r, t ,u\}$

> Welche Wörter liegen in $\Sigma^5$?

w1: r + e + in + e + r

w2: t + e + u + r + e ... (nicht in 5)

w3: t + r + e + u + e + ...(nicht in 5)

w4: t + e + u + r + en

w5: r + e + t + t + en

w6: t + e + u + e + r

---

52.

$\Sigma = \{e, el, g, i, ne, st\}$

> $\sigma^5$

w1: ja

w2: ja

w3: nein

w4: nein

w5: nein

w6: nein

---

53.

$\Sigma = \{e,g,in,l,s,ter\}$

> Welche Wörter liegen in $\Sigma^*$?

w1: (t ist nicht enthalten)

w2: s + e + ... (i ist nicht enthalten)

w3: l + in + e + s

w4: s + e + g + e + l

w5: s + e + in + e + ... (n nicht enthalten)

w6: e + ... (r nicht enthalten)

---

54.

$\Sigma = \{ber, e, he, in, sch, u\}$

> $\Sigma^*$

54.

w1 : nein

w2: ja

w3: nein

w4: ja

w5: ja

w5: ja