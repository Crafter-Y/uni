# Material

TODO

## Signalkodierung

Einsatz der Verfahren:

- Manchester bei Netzwerkschnittstellen (z.B. Ethernet)
  - Leitungseinsparung (TRG & GSF) kann von Vorteil sein, SSH ist bei längeren Strecken ebenfalls wichtig
  - Mit hohem BBB muss man dann leben
- NRZ: bei internen Schnittstellen (zwischen ICs oder zwischen Erweiterungskarten im Rechner)
  - Leitungseinsparung nicht relevant
  - SSH und BBB wichtig
  - Einfachheit des Verfahren
- RZ und AMI: heute praktisch nicht mehr eingesetzt

Unsere Verfahren der Signalcodierung arbeiten synchron (getaktet) und bitseriell

Bitseriell: Die einzelnen Bits werden nacheinander übertragen

Bitparallel: Mehrere Bits werden (über mehrere parallel verlaufende Leitungen) gleichzeitig übertragen

Problem: Die parallelen Leitungen haben leicht unterschiedliche Verzögerungen

=> Wenn diese Unterschiede im Bereich der Schrittzeit liegen (bei hochtaktigen Schnittstellen ist die Schrittzeit entsprechend klein), dann können die zusmmangehörigen (parallelen) Bits einander nicht mehr zugeordnet werden.

=> Unterschiedliche Signalverzögerung gilt auch für die parallel verlaufende Taktleitung

=> Deshalb ist TRG (z.B bei NRZ) auch bei vorhandener Taktleitung wichtig

3 Verfahren zur sicheren Taktrückgewinnung

a) Startbitsequenz

Vor einer Folge von n Nutzdaten setzen wir eine Startbitsequenz, welche sicher TRG ermöglicht (z.B. "01" oder "10" bei NRZ, "1" bei RZ oder AMI)

- Extrem einfaches und kostengünstiges Verfahren
- relativ großer Overhead (bei n = 8 und NRZ 20%, da für 8bit 10 Schritte benötigt werden), welcher auch dann anfällt, wenn die Nutzdaten perse TRG ermöglichen würden

b) Bit stuffing

Nach n gleichen Nutzdatenbits wird ein dazu inverses Stopfbit in den Datenstrom eingefügt (Vom Sender)

> Beispiel: $n=3$
>
> ```
> Nutzdaten: 110111 1000 000 0111 000 1
> Zähler:    121123 1123 123 1123 123
> Stopfbit:        0    1   1    0   1
> ```

Der Empfänger entfernt nach n gleichen Bit das nächste Bit als Stopfbit, sofern es den gegengesetzten Wert aufweist. Hat es nochmal den gleichen Bitwert, wird ein Fehler nach oben gemeldet.

- Deutlich komplexes, kostspieliges und fehleranfälliges Verfahren
- Deutlich geringerer Overhead (bei NRZ nur halb so groß wie bei Startbitsequenz), im besten Fall gar kein Overhead
- Overhead ist variabel f.h. die Nutzdatenrate ist nicht konstant
  - Nachteillig für Anwendungen mit konstanten Nutzdatenrate

c) Blockcodierung

Umcodierung, bei der ein Block von n Nutzdatenbit in einem Block von (n+1) zu übertragenden Datenbit umgesetzt wird. Dabei werden nur Blöcke verwednet, welche eine TRG sicher ermöglichen

> z.B. $n = 3$ und $i = 1$
>
> 000 - 0010
> 001 - 0100
> 010 - 0101
> 011 - 0110
> 100 - 1001
> 101 - 1010
> 110 - 1011
> 111 - 1101
>
> => 3B-4B-Blockcodierung ("Leitungscodierung")

- Erstellung der Tabelle etwas komplexer, aber Durchführung des Verfahrens (auch mit riesiger Tabelle extrem einfach)
- Overhead ist deutlich geringer (da n bei zweimaliger TRG größer gewählt werdem kann)
- Aber Overhead ist immer vorhanden
- Konstante Nutzdatenrate
- ggf. ist bei der Auswahl geeigneter Bitmuster auch die weitere Eigenschaft GSF (oder zumindest "GS-Armut" bei nicht zu großer Diskrepanz der Anzahl "0" von der Anzahl "1") möglich

Wie wird das eingesetzt?

a) Strtbitsequenz: z.B. Serielle Schnittstelle (z.B. RS232, RS485) und andere meist ältere Schnittstellen

- Erlaubt neben Resynchronisierung auch Initialsynchronisierung

b) Bitstuffing: z.B. CAN-BUS (in Autos, LKW, Bus und Bahn), auch bei Ethernet, hier aber nicht für TRG, sondern um das Bitmuster des Frame-Delimiter "01111110" im übertragenen Datenstrom auszuschließen.

c) Blockcodierung: 8B/10B bei ISDN, SATA, PCI

Bestimmung des Parameters n:

=> hängt ab von der maximalen zeitlichen Abweichung der einzelnen Schritte

=> Der Empfänger misst den Pegel in der Mitte der angenommenen Schrittzeit, da hier der zeitliche Abstand zum vorigen und nachfolgenden Schritt am größten ist.

=> Die zeitliche Abweichung darf maximal eine halbe Schrittzeit betragen

=> Die zeitliche Abweichung jedes der beiden Teilnehmer vom Soll darf nur eine viertel Schrittzeit betragen

> Ein Uhrenhersteller garantiert beispielsweise eine maximale Genauigkeit von 5%
>
> Damit wären nach 5 Schritten die 25% Abweichung erreicht
> Damit sollte $n \lt 5$ gewählt werden 

# Boolesche Algebra / Schaltalgebra

Benannt nach George Boole (1815-1864)

Rechensystem mit bestimmten Grundlagen/Regeln:

- endliche Wertemenge $\mathbb{W}$
- zwei zweistellige Operatoren : $\bigotimes, \bigoplus$
- Abgeschlossenheit: $\forall a,b \in \mathbb{W}$, $a'\bigotimes b \in \mathbb{W}$, $a \bigoplus b \in \mathbb{W}$
- Es gelten die Hunthingtonschen Axiome

**Huntington Axiome**

H1: Kommutativgesetz

$$
\begin{align*}
a \otimes b = b \otimes a \\
a \oplus b = b \oplus a
\end{align*}
$$

H2: Distributivgesetz

$$
\begin{align*}
a \otimes (b \oplus c) = (a \otimes b) \oplus (a \otimes c) \\
a \oplus (b \otimes c) = (a \oplus b) \otimes (a \oplus c) \\
\end{align*}
$$

H3: Neutrales Element

$$
\begin{align*}
a \otimes e = a \\
a \oplus n = a
\end{align*}
$$

H4: Inverses Element

$$
\begin{align*}
a \otimes \overline{a} = 1 \\
a \oplus \overline{a} = e
\end{align*}
$$

Achtung: Für beide Operatoren, dasselbe inverse Element; Das Ergebnis ist jeweils das neutrale Element des anderen Operators!

**Spezialfall Schaltalgebra**

Wertemenge enthällt genau zwei Werte:

$\mathbb{W} = \{0,1\} = \{falsch, wahr\} = \{false, true\}$

Zweistellige Operatoren: 

$\bigotimes: UND, AND, \land, \cdot$

$\bigoplus: ODER, OR, \lor, +$

Einstelliger Operator: $NICHT, NOT, \neg a, \overline{a}$

Die 4 Huntington Axiome der Schaltalgebra:

H1: 

$$
\begin{align*}
a \land b  = b \land a \\
a \lor b  = b \lor a 
\end{align*}
$$

H2:

$$
\begin{align*}
a \land (b \lor c) = (a \land b) \lor (a \land c) \\
a \lor (b \land c) = (a \lor b) \land (a \lor c)
\end{align*}
$$

H3:

$$
\begin{align*}
a \land 1 = a \\
a \lor 0 = a
\end{align*}
$$

H4:

$$
\begin{align*}
a \land \overline{a} = 0 \\
a \lor \overline{a} = 1
\end{align*}
$$